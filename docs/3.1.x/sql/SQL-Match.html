<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Match - OrientDB</title>


        <!-- Custom HTML head -->

        <meta name="description" content="OrientDB documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OrientDB</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sql---match"><a class="header" href="#sql---match">SQL - <code>MATCH</code></a></h1>
<p>Queries the database in a declarative manner, using pattern matching.  This feature was introduced in version 2.2.</p>
<p><strong>Simplified Syntax</strong></p>
<pre><code>MATCH 
  {
    [class: &lt;class&gt;], 
    [as: &lt;alias&gt;], 
    [where: (&lt;whereCondition&gt;)]
  }
  .&lt;functionName&gt;(){
    [class: &lt;className&gt;], 
    [as: &lt;alias&gt;], 
    [where: (&lt;whereCondition&gt;)], 
    [while: (&lt;whileCondition&gt;)],
    [maxDepth: &lt;number&gt;],    
    [depthAlias: &lt;identifier&gt; ], 
    [pathAlias: &lt;identifier&gt; ],     
    [optional: (true | false)]
  }*
  [,
    [NOT]
    {
      [as: &lt;alias&gt;], 
      [class: &lt;class&gt;], 
      [where: (&lt;whereCondition&gt;)]
    }
    .&lt;functionName&gt;(){
      [class: &lt;className&gt;], 
      [as: &lt;alias&gt;], 
      [where: (&lt;whereCondition&gt;)], 
      [while: (&lt;whileCondition&gt;)],
      [maxDepth: &lt;number&gt;],    
      [depthAlias: &lt;identifier&gt; ], 
      [pathAlias: &lt;identifier&gt; ],     
      [optional: (true | false)]
    }*
  ]*
RETURN [DISTINCT] &lt;expression&gt; [ AS &lt;alias&gt; ] [, &lt;expression&gt; [ AS &lt;alias&gt; ]]*
GROUP BY &lt;expression&gt; [, &lt;expression&gt;]*
ORDER BY &lt;expression&gt; [, &lt;expression&gt;]*
SKIP &lt;number&gt;
LIMIT &lt;number&gt;
</code></pre>
<ul>
<li><strong><code>&lt;class&gt;</code></strong> Defines a valid target class.</li>
<li><strong><code>as: &lt;alias&gt;</code></strong> Defines an alias for a node in the pattern.</li>
<li><strong><code>&lt;whereCondition&gt;</code></strong> Defines a filter condition to match a node in the pattern.  It supports the normal SQL <a href="SQL-Where.html"><code>WHERE</code></a> clause.  You can also use the <code>$currentMatch</code> and <code>$matched</code> <a href="#context-variables">context variables</a>.</li>
<li><strong><code>&lt;functionName&gt;</code></strong> Defines a graph function to represent the connection between two nodes.  For instance, <code>out()</code>, <code>in()</code>, <code>outE()</code>, <code>inE()</code>, etc.
For out(), in(), both() also a shortened <em>arrow</em> syntax is supported:
<ul>
<li><code>{...}.out(){...}</code> can be written as <code>{...}--&gt;{...}</code></li>
<li><code>{...}.out("EdgeClass"){...}</code> can be written as <code>{...}-EdgeClass-&gt;{...}</code></li>
<li><code>{...}.in(){...}</code> can be written as <code>{...}&lt;--{...}</code></li>
<li><code>{...}.in("EdgeClass"){...}</code> can be written as <code>{...}&lt;-EdgeClass-{...}</code></li>
<li><code>{...}.both(){...}</code> can be written as <code>{...}--{...}</code></li>
<li><code>{...}.both("EdgeClass"){...}</code> can be written as <code>{...}-EdgeClass-{...}</code></li>
</ul>
</li>
<li><strong><code>&lt;whileCondition&gt;</code></strong> Defines a condition that the statement must meet to allow the traversal of this path.  It supports the normal SQL <a href="SQL-Where.html"><code>WHERE</code></a> clause.  You can also use the <code>$currentMatch</code>, <code>$matched</code> and <code>$depth</code> <a href="#context-variables">context variables</a>.  For more information, see <a href="#deep-traversal">Deep Traversal While Condition</a>, below.</li>
<li><strong><code>&lt;maxDepth&gt;</code></strong> Defines the maximum depth for this single path.</li>
<li><strong><code>&lt;depthAlias&gt;</code></strong> (since 3.0M3) This is valid only if you have a <code>while</code> or a <code>maxDepth</code>. It defines the alias to be used to store the depth of this traversal. This alias can be used in the <code>RETURN</code> block to retrieve the depth of current traversal.</li>
<li><strong><code>&lt;pathAlias&gt;</code></strong> (since 3.0M3) This is valid only if you have a <code>while</code> or a <code>maxDepth</code>. It defines the alias to be used to store the elements traversed to reach this alias. This alias can be used in the <code>RETURN</code> block to retrieve the elements traversed to reach this alias.</li>
<li><strong><code>RETURN &lt;expression&gt; [ AS &lt;alias&gt; ]</code></strong> Defines elements in the pattern that you want returned.  It can use one of the following:
<ul>
<li>Aliases defined in the <code>as:</code> block.</li>
<li><code>$matches</code> Indicating all defined aliases.</li>
<li><code>$paths</code> Indicating the full traversed paths.</li>
<li><code>$elements</code> (since 2.2.1) Indicating that all the elements that would be returned by the $matches have to be returned flattened, without duplicates.</li>
<li><code>$pathElements</code> (since 2.2.1) Indicating that all the elements that would be returned by the $paths have to be returned flattened, without duplicates.</li>
</ul>
</li>
<li><strong><code>optional</code></strong> (since 2.2.4) if set to true, allows to evaluate and return a pattern even if that particular node does not match the pattern itself (ie. there is no value for that node in the pattern). In current version, optional nodes are allowed only on right terminal nodes, eg. <code>{} --&gt; {optional:true}</code> is allowed, <code>{optional:true} &lt;-- {}</code> is not.</li>
<li><strong><code>NOT</code> patterns</strong> (since 3.0.3 - experimental) Together with normal patterns, you can also define negative patterns. A result will be returned only if it also DOES NOT match any of the negative patterns, ie. if it matches at least one of the negative patterns it won't be returned.</li>
</ul>
<p><strong>Examples</strong></p>
<p>The following examples are based on this sample data-set from the class <code>People</code>:</p>
<p><img src="../images/match-example-table.png" alt="" /></p>
<p><img src="../images/match-example-graph.png" alt="" /></p>
<ul>
<li>
<p>Find all people with the name John:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH 
              {class: Person, as: people, where: (name = 'John')} 
          RETURN people</code>

---------
  people 
---------
  #12:0
  #12:1
---------
</pre>
</li>
<li>
<p>Find all people with the name John and the surname Smith:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH 
              {class: Person, as: people, where: (name = 'John' AND surname = 'Smith')} 
      RETURN people</code>

-------
people
-------
 #12:1
-------
</pre>
</li>
<li>
<p>Find people named John with their friends:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH 
                {class: Person, as: person, where: (name = 'John')}.both('Friend') {as: friend} 
          RETURN person, friend</code>

--------+---------
 person | friend 
--------+---------
 #12:0  | #12:1
 #12:0  | #12:2
 #12:0  | #12:3
 #12:1  | #12:0
 #12:1  | #12:2
--------+---------
</pre>
</li>
<li>
<p>Find friends of friends:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH 
                  {class: Person, as: person, where: (name = 'John' AND surname = 'Doe')}
  	    .both('Friend').both('Friend') {as: friendOfFriend} 
  	RETURN person, friendOfFriend</code>

--------+----------------
 person | friendOfFriend 
--------+----------------
 #12:0  | #12:0
 #12:0  | #12:1
 #12:0  | #12:2
 #12:0  | #12:3
 #12:0  | #12:4
--------+----------------
</pre>
</li>
<li>
<p>Find people, excluding the current user:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person, where: (name = 'John' AND 
          surname = 'Doe')}.both('Friend').both('Friend'){as: friendOfFriend,
  		where: ($matched.person != $currentMatch)} 
  		RETURN person, friendOfFriend</code>

--------+----------------
 person | friendOfFriend
--------+----------------
 #12:0  | #12:1
 #12:0  | #12:2
 #12:0  | #12:3
 #12:0  | #12:4
--------+----------------
</pre>
</li>
<li>
<p>Find friends of friends to the sixth degree of separation:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person, where: (name = 'John' AND 
          surname = 'Doe')}.both('Friend'){as: friend, 
  		where: ($matched.person != $currentMatch) while: ($depth < 6)} 
  		RETURN person, friend</code>

--------+---------
 person | friend
--------+---------
 #12:0  | #12:0
 #12:0  | #12:1
 #12:0  | #12:2
 #12:0  | #12:3
 #12:0  | #12:4
--------+---------
</pre>
</li>
<li>
<p>Finding friends of friends to six degrees of separation, since a particular date:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person, 
          where: (name = 'John')}.(bothE('Friend'){
  		where: (date < ?)}.bothV()){as: friend, 
  		while: ($depth < 6)} RETURN person, friend</code>
</pre>
<p>In this case, the condition <code>$depth &lt; 6</code> refers to traversing the block <code>bothE('Friend')</code> six times.</p>
</li>
<li>
<p>Find friends of my friends who are also my friends, using multiple paths:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person, where: (name = 'John' AND 
          surname = 'Doe')}.both('Friend').both('Friend'){as: friend},
  		{ as: person }.both('Friend'){ as: friend } 
  		RETURN person, friend</code>

--------+--------
 person | friend
--------+--------
 #12:0  | #12:1
 #12:0  | #12:2
--------+--------
</pre>
<p>In this case, the statement matches two expression: the first to friends of friends, the second to direct friends.  Each expression shares the common aliases (<code>person</code> and <code>friend</code>). To match the whole statement, the result must match both expressions, where the alias values for the first expression are the same as that of the second.</p>
</li>
<li>
<p>Find common friends of John and Jenny:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'John' AND 
          surname = 'Doe')}.both('Friend'){as: friend}.both('Friend')
  		{class: Person, where: (name = 'Jenny')} RETURN friend</code>

--------
 friend
--------
 #12:1
--------
</pre>
<p>The same, with two match expressions:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'John' AND 
          surname = 'Doe')}.both('Friend'){as: friend}, 
  		{class: Person, where: (name = 'Jenny')}.both('Friend')
  		{as: friend} RETURN friend</code>
</pre>
</li>
</ul>
<h2 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h2>
<p>In v 3.0 the MATCH statement returns all the occurrences of a pattern, even if they are duplicated. To have unique, distinct records
as a result, you have to specify the DISTINCT keyword in the RETURN statement.</p>
<p>Example: suppose you have a dataset made like following:</p>
<p>INSERT INTO V SET name = 'John', surname = 'Smith';
INSERT INTO V SET name = 'John', surname = 'Harris'
INSERT INTO V SET name = 'Jenny', surname = 'Rose'</p>
<p>This is the result of the query without a DISTINCT clause:</p>
  <pre>
  orientdb> <code class="lang-sql userinput">MATCH {class: Person, as:p} RETURN p.name as name</code>

  --------
   name
  --------
   John
  --------
   John
  --------
   Jenny
  --------
  </pre>
<p>And this is the result of the query with a DISTINCT clause:</p>
  <pre>
  orientdb> <code class="lang-sql userinput">MATCH {class: Person, as:p} RETURN DISTINCT p.name as name</code>

  --------
   name
  --------
   John
  --------
   Jenny
  --------
  </pre>
<blockquote>
<p>IMPORTANT: in V 2.2 it was not possible to specify DISTINCT keyword in the RETURN block and the DISTINCT was implicit.</p>
</blockquote>
<blockquote>
<p>IMPORTANT: in V 3.0, using the <strong>legacy Java API</strong>, the behavior will be the same as in v 2.2</p>
</blockquote>
<h2 id="context-variables"><a class="header" href="#context-variables">Context Variables</a></h2>
<p>When running these queries, you can use any of the following context variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>$matched</code></td><td>Gives the current matched record.  You must explicitly define the attributes for this record in order to access them.  You can use this in the <code>where:</code> and <code>while:</code> conditions to refer to current partial matches or as part of the <code>RETURN</code> value.</td></tr>
<tr><td><code>$currentMatch</code></td><td>Gives the current complete node during the match.</td></tr>
<tr><td><code>$depth</code></td><td>Gives the traversal depth, following a single path item where a <code>while:</code> condition is defined.</td></tr>
</tbody></table>
</div>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="expanding-attributes"><a class="header" href="#expanding-attributes">Expanding Attributes</a></h3>
<p>You can run this statement as a sub-query inside of another statement.  Doing this allows you to obtain details and aggregate data from the inner <a href="SQL-Query.html"><code>SELECT</code></a> query.</p>
<pre>
orientdb> <code class="lang-sql userinput">SELECT person.name AS name, person.surname AS surname,
          friend.name AS friendName, friend.surname AS friendSurname
		  FROM (MATCH {class: Person, as: person,
		  where: (name = 'John')}.both('Friend'){as: friend}
		  RETURN person, friend)</code>

--------+----------+------------+---------------
 name   | surname  | friendName | friendSurname
--------+----------+------------+---------------
 John   | Doe      | John       | Smith
 John   | Doe      | Jenny      | Smith
 John   | Doe      | Frank      | Bean
 John   | Smith    | John       | Doe
 John   | Smith    | Jenny      | Smith
--------+----------+------------+---------------
</pre>
<p>As an alternative, you can use the following:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person,
		  where: (name = 'John')}.both('Friend'){as: friend}
		  RETURN 
		  person.name as name, person.surname as surname, 
		  friend.name as firendName, friend.surname as friendSurname</code>

--------+----------+------------+---------------
 name   | surname  | friendName | friendSurname
--------+----------+------------+---------------
 John   | Doe      | John       | Smith
 John   | Doe      | Jenny      | Smith
 John   | Doe      | Frank      | Bean
 John   | Smith    | John       | Doe
 John   | Smith    | Jenny      | Smith
--------+----------+------------+---------------
</pre>
<h3 id="incomplete-hierarchy"><a class="header" href="#incomplete-hierarchy">Incomplete Hierarchy</a></h3>
<p>Consider building a database for a company that shows a hierarchy of departments within the company.  For instance,</p>
<pre><code>           [manager] department        
          (employees in department)    
                                       
                                       
                [m0]0                   
                 (e1)                  
                 /   \                 
                /     \                
               /       \               
           [m1]1        [m2]2
          (e2, e3)     (e4, e5)        
             / \         / \           
            3   4       5   6          
          (e6) (e7)   (e8)  (e9)       
          /  \                         
      [m3]7    8                       
      (e10)   (e11)                    
       /                               
      9                                
  (e12, e13)                         
</code></pre>
<p>This loosely shows that,</p>
<ul>
<li>Department <code>0</code> is the company itself, manager 0 (<code>m0</code>) is the CEO</li>
<li><code>e10</code> works at department <code>7</code>, his manager is <code>m3</code></li>
<li><code>e12</code> works at department <code>9</code>, this department has no direct manager, so <code>e12</code>'s manager is <code>m3</code> (the upper manager)</li>
</ul>
<p>In this case, you would use the following query to find out who's the manager to a particular employee:</p>
<pre>
orientdb> <code class="lang-sql userinput">SELECT EXPAND(manager) FROM (MATCH {class:Employee, 
          where: (name = ?)}.out('WorksAt').out('ParentDepartment')
		  {while: (out('Manager').size() == 0), 
		  where: (out('Manager').size() > 0)}.out('Manager')
		  {as: manager} RETURN manager)</code>
</pre>
<h3 id="deep-traversal"><a class="header" href="#deep-traversal">Deep Traversal</a></h3>
<p>Match path items act in a different manners, depending on whether or not you use <code>while:</code> conditions in the statement.</p>
<p>For instance, consider the following graph:</p>
<pre><code>[name='a'] -FriendOf-&gt; [name='b'] -FriendOf-&gt; [name='c']
</code></pre>
<p>Running the following statement on this graph only returns <code>b</code>:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'a')}.out("FriendOf")
          {as: friend} RETURN friend</code>

--------
 friend 
--------
 b
--------
</pre>
<p>What this means is that it traverses the path item <code>out("FriendOf")</code> exactly once.  It only returns the result of that traversal.</p>
<p>If you add a <code>while</code> condition:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'a')}.out("FriendOf")
          {as: friend, while: ($depth < 2)} RETURN friend</code>

---------
 friend 
---------
 a
 b
---------
</pre>
<p>Including a <code>while:</code> condition on the match path item causes OrientDB to evaluate this item as zero to <em>n</em> times.  That means that it returns the starting node, (<code>a</code>, in this case), as the result of zero traversal.</p>
<p>To exclude the starting point, you need to add a <code>where:</code> condition, such as:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'a')}.out("FriendOf")
          {as: friend, while: ($depth < 2) where: ($depth > 0)} 
		  RETURN friend</code>
</pre>
<p>As a general rule,</p>
<ul>
<li><strong><code>while</code> Conditions:</strong> Define this if it must execute the next traversal, (it evaluates at level zero, on the origin node).</li>
<li><strong><code>where</code> Condition:</strong> Define this if the current element, (the origin node at the zero iteration the right node on the iteration is greater than zero), must be returned as a result of the traversal.</li>
</ul>
<p>For instance, suppose that you have a genealogical tree.  In the tree, you want to show a person, grandparent and the grandparent of that grandparent, and so on.  The result: saying that the person is at level zero, parents at level one, grandparents at level two, etc., you would see all ancestors on even levels.  That is, <code>level % 2 == 0</code>.</p>
<p>To get this, you might use the following query:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'a')}.out("Parent")
          {as: ancestor, while: (true) where: ($depth % 2 = 0)} 
		  RETURN ancestor</code>
</pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h2>
<p>Queries can involve multiple operations, based on the domain model and use case.  In some cases, like projection and aggregation, you can easily manage them with a <a href="SQL-Query.html"><code>SELECT</code></a> query.  With others, such as pattern matching and deep traversal, <a href="SQL-Match.html"><code>MATCH</code></a> statements are more appropriate.</p>
<p>Use <a href="SQL-Query.html"><code>SELECT</code></a> and <a href="SQL-Match.html"><code>MATCH</code></a> statements together (that is, through sub-queries), to give each statement the correct responsibilities.  Here,</p>
<h3 id="filtering-record-attributes-for-a-single-class"><a class="header" href="#filtering-record-attributes-for-a-single-class">Filtering Record Attributes for a Single Class</a></h3>
<p>Filtering based on record attributes for a single class is a trivial operation through both statements.  That is, finding all people named John can be written as:</p>
<pre>
orientdb> <code class="lang-sql userinput">SELECT FROM Person WHERE name = 'John'</code>
</pre>
<p>You can also write it as,</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person, where: (name = 'John')} 
          RETURN person</code>
</pre>
<p>The efficiency remains the same.  Both queries use an index.  With <a href="SQL-Query.html"><code>SELECT</code></a>, you obtain expanded records, while with <a href="SQL-Match.html"><code>MATCH</code></a>, you only obtain the Record ID's.</p>
<h3 id="filtering-on-record-attributes-of-connected-elements"><a class="header" href="#filtering-on-record-attributes-of-connected-elements">Filtering on Record Attributes of Connected Elements</a></h3>
<p>Filtering based on the record attributes of connected elements, such as neighboring vertices, can grow trick when using <a href="SQL-Query.html"><code>SELECT</code></a>, while with <a href="SQL-Match.html"><code>MATCH</code></a> it is simple.</p>
<p>For instance, find all people living in Rome that have a friend called John.  There are three different ways you can write this,  using <a href="SQL-Query.html"><code>SELECT</code></a>:</p>
<pre>
orientdb> <code class="lang-sql userinput">SELECT FROM Person WHERE BOTH('Friend').name CONTAINS 'John'
          AND out('LivesIn').name CONTAINS 'Rome'</code>

orientdb> <code class="lang-sql userinput">SELECT FROM (SELECT BOTH('Friend') FROM Person WHERE name
          'John') WHERE out('LivesIn').name CONTAINS 'Rome'</code>

orientdb> <code class="lang-sql userinput">SELECT FROM (SELECT in('LivesIn') FROM City WHERE name = 'Rome')
          WHERE BOTH('Friend').name CONTAINS 'John'</code>
</pre>
<p>In the first version, the query is more readable, but it does not use indexes, so it is less optimal in terms of execution time.  The second and third use indexes if they exist, (on <code>Person.name</code> or <code>City.name</code>, both in the sub-query), but they're harder to read.  Which index they use depends only on the way you write the query.  That is, if you only have an index on <code>City.name</code> and not <code>Person.name</code>, the second version doesn't use an index.</p>
<p>Using a <a href="SQL-Match.html"><code>MATCH</code></a> statement, the query becomes:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'John')}.both("Friend")
          {as: result}.out('LivesIn'){class: City, where: (name = 'Rome')}
		  RETURN result</code>
</pre>
<p>Here, the query executor optimizes the query for you, choosing indexes where they exist.  Moreover, the query becomes more readable, especially in complex cases, such as multiple nested <a href="SQL-Query.html"><code>SELECT</code></a> queries.</p>
<h3 id="traverse-alternative"><a class="header" href="#traverse-alternative"><code>TRAVERSE</code> Alternative</a></h3>
<p>There are similar limitations to using <a href="SQL-Traverse.html"><code>TRAVERSE</code></a>.  You may benefit from using <a href="SQL-Match.html"><code>MATCH</code></a> as an alternative.</p>
<p>For instance, consider a simple <a href="SQL-Traverse.html"><code>TRAVERSE</code></a> statement, like:</p>
<pre>
orientdb> <code class="lang-sql userinput">TRAVERSE out('Friend') FROM (SELECT FROM Person WHERE name = 'John') 
          WHILE $depth < 3</code>
</pre>
<p>Using a <a href="SQL-Match.html"><code>MATCH</code></a> statement, you can write the same query as:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'John')}.both("Friend")
          {as: friend, while: ($depth < 3)} RETURN friend</code>
</pre>
<p>Consider a case where you have a <code>since</code> date property on the edge <code>Friend</code>.  You want to traverse the relationship only for edges where the <code>since</code> value is greater than a given date.  In a <a href="SQL-Traverse.html"><code>TRAVERSE</code></a> statement, you might write the query as:</p>
<pre>
orientdb> <code class="lang-sql userinput">TRAVERSE bothE('Friend')[since > date('2012-07-02', 'yyyy-MM-dd')].bothV()
          FROM (SELECT FROM Person WHERE name = 'John') WHILE $depth < 3</code>
</pre>
<p>Unforunately, this statement DOESN"T WORK in the current release.  However, you can get the results you want using a <a href="SQL-Match.html"><code>MATCH</code></a> statement:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, where: (name = 'John')}.(bothE("Friend")
          {where: (since > date('2012-07-02', 'yyyy-MM-dd'))}.bothV())
		  {as: friend, while: ($depth < 3)} RETURN friend</code>
</pre>
<h3 id="projections-and-grouping-operations"><a class="header" href="#projections-and-grouping-operations">Projections and Grouping Operations</a></h3>
<p>Projections and grouping operations are better expressed with a <a href="SQL-Query.html"><code>SELECT</code></a> query.  If you need to filter and do projection or aggregation in the same query, you can use <a href="SQL-Query.html"><code>SELECT</code></a> and <a href="SQL-Match.html"><code>MATCH</code></a> in the same statement.</p>
<p>This is particular important when you expect a result that contains attributes from different connected records (cartesian product).  For instance, to retrieve names, their friends and the date since they became friends:</p>
<pre>
orientdb> <code class="lang-sql userinput">SELECT person.name AS name, friendship.since AS since, friend.name 
          AS friend FROM (MATCH {class: Person, as: person}.bothE('Friend')
		  {as: friendship}.bothV(){as: friend, 
		  where: ($matched.person != $currentMatch)} 
		  RETURN person, friendship, friend)</code>
</pre>
<p>The same can be also achieved with the MATCH only:</p>
<pre>
orientdb> <code class="lang-sql userinput">MATCH {class: Person, as: person}.bothE('Friend')
		  {as: friendship}.bothV(){as: friend, 
		  where: ($matched.person != $currentMatch)} 
		  RETURN person.name as name, friendship.since as since, friend.name as friend</code>
</pre>
<h3 id="return-expressions"><a class="header" href="#return-expressions">RETURN expressions</a></h3>
<p>In the RETURN section you can use:</p>
<p><strong>multiple expressions</strong>, with or without an alias (if no alias is defined, OrientDB will generate a default alias for you), comma separated</p>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){as: friendship}
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN person, friendship, friend

result: 

| person | friendship | friend |
--------------------------------
| #12:0  | #13:0      | #12:2  |
| #12:0  | #13:1      | #12:3  |
| #12:1  | #13:2      | #12:3  |
</code></pre>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){as: friendship}
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN person.name as name, friendship.since as since, friend.name as friend

result: 

| name | since | friend |
-------------------------
| John | 2015  | Frank  |
| John | 2015  | Jenny  |
| Joe  | 2016  | Jenny  |

</code></pre>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){as: friendship}
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN person.name + " is a friend of " + friend.name as friends

result: 

| friends                    |
------------------------------
| John is a friend of Frank  |
| John is a friend of Jenny  |
| Joe is a friend of Jenny   |

</code></pre>
<p><strong>$matches</strong>, to return all the patterns that match current statement. Each row in the result set will be a single pattern, containing only nodes in the statement that have an <code>as:</code> defined</p>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){}                                                  // no 'as:friendship' in this case
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN $matches

result: 

| person |  friend | 
--------------------
| #12:0  |  #12:2  |
| #12:0  |  #12:3  |
| #12:1  |  #12:3  |

</code></pre>
<p><strong>$paths</strong>, to return all the patterns that match current statement. Each row in the result set will be a single pattern, containing all th nodes in the statement. For nodes that have an <code>as:</code>, the alias will be returned, for the others a default alias is generated (automatically generated aliases start with <code>$ORIENT_DEFAULT_ALIAS_</code>)</p>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){}                                                  // no 'as:friendship' in this case
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN $paths

result: 

| person | friend | $ORIENT_DEFAULT_ALIAS_0 |
---------------------------------------------
| #12:0  | #12:2  | #13:0                   |
| #12:0  | #12:3  | #13:1                   |
| #12:1  | #12:3  | #13:2                   |
</code></pre>
<p><strong>$elements</strong> (since 2.2.1), the same as <code>$matches</code>, but for each node present in the pattern, a single row is created in the result set (no duplicates)</p>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){}                                                  // no 'as:friendship' in this case
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN $elements

result: 

| @rid   |  @class | name   |  .....   |
----------------------------------------
| #12:0  |  Person | John   |  .....   |
| #12:1  |  Person | Joe    |  .....   |
| #12:2  |  Person | Frank  |  .....   |
| #12:3  |  Person | Jenny  |  .....   |

</code></pre>
<p><strong>$pathElements</strong> (since 2.2.1), the same as <code>$paths</code>, but for each node present in the pattern, a single row is created in the result set (no duplicates)</p>
<pre><code>MATCH 
  {class: Person, as: person}
  .bothE('Friend'){}                                                  // no 'as:friendship' in this case
  .bothV(){as: friend, where: ($matched.person != $currentMatch)} 
RETURN $pathElements

result: 

| @rid   |  @class | name   | since  |  .....   |
-------------------------------------------------
| #12:0  |  Person | John   |        |  .....   |
| #12:1  |  Person | Joe    |        |  .....   |
| #12:2  |  Person | Frank  |        |  .....   |
| #12:3  |  Person | Jenny  |        |  .....   |
| #13:0  |  Friend |        |  2015  |  .....   |
| #13:1  |  Friend |        |  2015  |  .....   |
| #13:2  |  Friend |        |  2016  |  .....   |

</code></pre>
<p><strong>IMPORTANT</strong>: When using MATCH statemet in OrientDB Studio Graph panel you have to use $elements or $pathElements as return type, to let the Graph panel render the matched patterns correctly</p>
<h3 id="arrow-notation"><a class="header" href="#arrow-notation">Arrow notation</a></h3>
<p><code>out()</code>, <code>in()</code> and <code>both()</code> operators can be replaced with arrow notation <code>--&gt;</code>, <code>&lt;--</code> and <code>--</code></p>
<p>Eg. the query</p>
<pre>
<code class="lang-sql userinput">
MATCH {class: V, as: a}.out(){}.out(){}.out(){as:b}
RETURN a, b
</code>
</pre>
<p>can be written as</p>
<pre>
<code class="lang-sql userinput">
MATCH {class: V, as: a} --> {} --> {} --> {as:b}
RETURN a, b
</code>
</pre>
<p>Eg. the query (things that belong to friends)</p>
<pre>
<code class="lang-sql userinput">
MATCH {class: Person, as: a}.out('Friend'){as:friend}.in('BelongsTo'){as:b}
RETURN a, b
</code>
</pre>
<p>can be written as</p>
<pre>
<code class="lang-sql userinput">
MATCH {class: Person, as: a}  -Friend-> {as:friend} <-BelongsTo- {as:b}
RETURN a, b
</code>
</pre>
<p>Using arrow notation the curly braces are mandatory on both sides. eg:</p>
<pre>
<code class="lang-sql userinput">
MATCH {class: Person, as: a} --> {} --> {as:b} RETURN a, b  //is allowed

MATCH {class: Person, as: a} --> --> {as:b} RETURN a, b  //is NOT allowed

MATCH {class: Person, as: a}.out().out(){as:b} RETURN a, b  //is allowed

MATCH {class: Person, as: a}.out(){}.out(){as:b} RETURN a, b  //is allowed
</code>
</pre>
<h3 id="negative-not-patterns"><a class="header" href="#negative-not-patterns">Negative (NOT) patterns</a></h3>
<p>(since 3.0.3 - experimental)</p>
<p>Together with normal patterns, you can also define negative patterns. A result will be returned only if it also DOES NOT match any of the negative patterns, ie. if the result matches at least one of the negative patterns it won't be returned.</p>
<p>As an example, consider the following problem: given a social network, choose a single person and return all the people that are friends of their friends, but that are not their direct friends.</p>
<p>The pattern can be calculated as follows:</p>
<pre>
<code class="lang-sql userinput">
MATCH
  {class:Person, as:a, where:(name = "John")} -FriendOf-> {as:b} -FriendOf-> {as:c},
  NOT {as:a} -FriendOf-> {as:c}
RETURN c.name
</code>
</pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../sql/SQL-Live-Unsubscribe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../sql/SQL-Move-Vertex.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../sql/SQL-Live-Unsubscribe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../sql/SQL-Move-Vertex.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        
        <img referrerpolicy="unsafe-url" src="https://tglman.org/OrientDB/matomo.php?idsite=7&amp;rec=1" style="border:0" alt="" />


        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
