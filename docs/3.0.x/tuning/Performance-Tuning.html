<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Performance Tuning - OrientDB</title>


        <!-- Custom HTML head -->

        <meta name="description" content="OrientDB documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OrientDB</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h1>
<p>This guide contains the general tips to optimize your application that use the OrientDB. Below you can find links for the specific guides different per database type used. Look at the specific guides based on the database type you're using:</p>
<ul>
<li><a href="Performance-Tuning-Document.html">Document Database performance tuning</a></li>
<li><a href="Performance-Tuning-Object.html">Object Database performance tuning</a></li>
<li><a href="../distributed/Distributed-Configuration-Tuning.html">Distributed Configuration tuning</a></li>
</ul>
<h2 id="io-benchmark"><a class="header" href="#io-benchmark">I/O benchmark</a></h2>
<p>The main requirement for a fast DBMS is having good I/O. In order to understand the performance of your hw/sw configuration. If you have a Unix derived OS (like Linux, MacOSX, etc.), the simplest way to have your raw I/O performance is running this two commands:</p>
<pre><code>dd if=/dev/zero of=/tmp/output.img bs=8k count=256k
rm /tmp/output.img
</code></pre>
<p>This is the output on a fast SSD (1.4 GB/sec):</p>
<pre><code>262144+0 records in
262144+0 records out
2147483648 bytes transferred in 1.467536 secs (1463326070 bytes/sec)
</code></pre>
<p>And this is what you usually get with a HD connected with a USB 3.0 (90 MB/sec):</p>
<pre><code>262144+0 records in
262144+0 records out
2147483648 bytes transferred in 23.699740 secs (90612119 bytes/sec)
</code></pre>
<p>As you can notice the first configuration (SSD) is 16x faster than the second configuration (HD). Sensible differences can be found between bare metal hw and Virtual Machines.</p>
<h2 id="java"><a class="header" href="#java">Java</a></h2>
<p>OrientDB is written in Java, so it runs on top of Java Virtual Machine (JVM). OrientDB is compatible with Java 8 and we suggest to use this version to run OrientDB. Java 8 is faster than Java 7 and previous ones.</p>
<h2 id="jmx"><a class="header" href="#jmx">JMX</a></h2>
<p>Starting from v2.1, OrientDB exposes internal metrics through <a href="../admin/JMX.html">JMX Beans</a>. Use this information to track and profile OrientDB.</p>
<h2 id="memory-settings"><a class="header" href="#memory-settings">Memory settings</a></h2>
<h3 id="server-and-embedded-settings"><a class="header" href="#server-and-embedded-settings">Server and Embedded settings</a></h3>
<p>These settings are valid for both Server component and the JVM where is running the Java application that use OrientDB in Embedded Mode, by using directly <a href="../internals/plocal-storage-engine.html">plocal</a>.</p>
<p>The most important thing on tuning is assuring the memory settings are correct. What can make the real difference is the right balancing between the heap and the virtual memory used by Memory Mapping, specially on large datasets (GBs, TBs and more) where the in memory cache structures count less than raw IO.</p>
<p>For example if you can assign maximum 8GB to the Java process, it's usually better assigning small heap and large disk cache buffer (off-heap memory). So rather than:</p>
<pre><code>java -Xmx8g ...
</code></pre>
<p>You could instead try this:</p>
<pre><code>java -Xmx800m -Dstorage.diskCache.bufferSize=7200 ...
</code></pre>
<p>The <strong>storage.diskCache.bufferSize</strong> setting (with old "local" storage it was <strong>file.mmap.maxMemory</strong>) is in MB and tells how much memory to use for <a href="../internals/plocal-storage-disk-cache.html">Disk Cache</a> component. By default is 4GB.</p>
<p><em>NOTE: If the sum of maximum heap and disk cache buffer is too high, could cause the OS to swap with huge slow down.</em></p>
<h2 id="jvm-settings"><a class="header" href="#jvm-settings">JVM settings</a></h2>
<p>JVM settings are encoded in server.sh (and server.bat) batch files. You can change them to tune the JVM according to your usage and hw/sw settings. We found these setting work well on most configurations:</p>
<pre><code class="language-java">-server -XX:+PerfDisableSharedMem
</code></pre>
<p>This setting will disable writing debug information about the JVM. In case you need to profile the JVM, just remove this setting. For more information look at this post: http://www.evanjones.ca/jvm-mmap-pause.html.</p>
<h3 id="high-concurrent-updates"><a class="header" href="#high-concurrent-updates">High concurrent updates</a></h3>
<p>OrientDB has an optimistic concurrency control system, but on very high concurrent updates on the few records it could be more efficient locking records to avoid retries. You could synchronize the access by yourself or by using the storage API. Note that this works only with non-remote databases.</p>
<pre><code>((OStorageEmbedded)db.getStorage()).acquireWriteLock(final ORID iRid)
((OStorageEmbedded)db.getStorage()).acquireSharedLock(final ORID iRid)
((OStorageEmbedded)db.getStorage()).releaseWriteLock(final ORID iRid)
((OStorageEmbedded)db.getStorage()).releaseSharedLock(final ORID iRid)
</code></pre>
<p>Example of usage. Writer threads:</p>
<pre><code>try{
  ((OStorageEmbedded)db.getStorage()).acquireWriteLock(record.getIdentity());

  // DO SOMETHING
} finally {
  ((OStorageEmbedded)db.getStorage()).releaseWriteLock(record.getIdentity());
}
</code></pre>
<p>Reader threads:</p>
<pre><code>try{
  ((OStorageEmbedded)db.getStorage()).acquireSharedLock(record.getIdentity());
  // DO SOMETHING

} finally {
  ((OStorageEmbedded)db.getStorage()).releaseSharedLock(record.getIdentity());
}
</code></pre>
<h2 id="remote-connections"><a class="header" href="#remote-connections">Remote connections</a></h2>
<p>There are many ways to improve performance when you access to the database using the remote connection.</p>
<h3 id="fetching-strategy"><a class="header" href="#fetching-strategy">Fetching strategy</a></h3>
<p>When you work with a remote database you've to pay attention to the <a href="../java/Fetching-Strategies.html">fetching strategy</a> used. By default OrientDB Client loads only the record contained in the result set. For example if a query returns 100 elements, but then you cross these elements from the client, then OrientDB client lazily loads the elements with one more network call to the server foreach missed record.</p>
<p>By specifying a fetch plan when you execute a command you're telling to OrientDB to prefetch the elements you know the client application will access. By specifying a complete fetch plan you could receive the entire result in <em>just one network call</em>.</p>
<p>For more information look at: <a href="../java/Fetching-Strategies.html">Fetching-Strategies</a>.</p>
<h3 id="network-connection-pool"><a class="header" href="#network-connection-pool">Network Connection Pool</a></h3>
<p>Each client, by default, uses only one network connection to talk with the server. Multiple threads on the same client share the same network connection pool.</p>
<p>When you've multiple threads could be a bottleneck since a lot of time is spent on waiting for a free network connection. This is the reason why is much important to configure the network connection pool.</p>
<p>The configurations is very simple, just 2 parameters:</p>
<ul>
<li><strong>minPool</strong>, is the initial size of the connection pool. The default value is configured as global parameters "client.channel.minPool" (see <a href="../admin/Configuration.html#parameters">parameters</a>)</li>
<li><strong>maxPool</strong>, is the maximum size the connection pool can reach. The default value is configured as global parameters "client.channel.maxPool" (see <a href="../admin/Configuration.html#parameters">parameters</a>)</li>
</ul>
<p>At first connection the <strong>minPool</strong> is used to pre-create network connections against the server. When a client thread is asking for a connection and all the pool is busy, then it tries to create a new connection until <strong>maxPool</strong> is reached.</p>
<p>If all the pool connections are busy, then the client thread will wait for the first free connection.</p>
<p>Example of configuration by using database properties:</p>
<pre><code class="language-java">database = new ODatabaseDocumentTx("remote:localhost/demo");
database.setProperty("minPool", 2);
database.setProperty("maxPool", 5);

database.open("admin", "admin");
</code></pre>
<h3 id="enlarge-timeouts"><a class="header" href="#enlarge-timeouts">Enlarge timeouts</a></h3>
<p>If you see a lot of messages like:</p>
<pre><code>WARNING: Connection re-acquired transparently after XXXms and Y retries: no errors will be thrown at application level
</code></pre>
<p>means that probably default timeouts are too low and server side operation need more time to complete. It's strongly suggested you enlarge your timeout only after tried to enlarge the <a href="#network-connection-pool">Network Connection Pool</a>. The timeout parameters to tune are:</p>
<ul>
<li><code>network.lockTimeout</code>, the timeout in ms to acquire a lock against a channel. The default is 15 seconds.</li>
<li><code>network.socketTimeout</code>, the TCP/IP Socket timeout in ms. The default is 10 seconds.</li>
</ul>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<h3 id="use-of-indexes"><a class="header" href="#use-of-indexes">Use of indexes</a></h3>
<p>The first improvement to speed up queries is to create <a href="../indexing/Indexes.html">Indexes</a> against the fields used in WHERE conditions. For example this query:</p>
<pre><code class="language-sql">SELECT FROM Profile WHERE name = 'Jay'
</code></pre>
<p>Browses the entire "profile" cluster looking for records that satisfy the conditions. The solution is to create an index against the 'name' property with:</p>
<pre><code class="language-sql">CREATE INDEX profile.name UNIQUE
</code></pre>
<p>Use NOTUNIQUE instead of UNIQUE if the value is not unique.</p>
<p>For more complex queries like</p>
<pre><code class="language-sql">SELECT * FROM testClass WHERE prop1 = ? AND prop2 = ?
</code></pre>
<p>Composite index should be used</p>
<pre><code class="language-sql">CREATE INDEX compositeIndex ON testClass (prop1, prop2) UNIQUE
</code></pre>
<p>or via Java API:</p>
<pre><code class="language-java">oClass.createIndex("compositeIndex", OClass.INDEX_TYPE.UNIQUE, "prop1", "prop2");
</code></pre>
<p>Moreover, because of partial match searching, this index will be used for optimizing query like</p>
<pre><code class="language-sql">SELECT * FROM testClass WHERE prop1 = ?
</code></pre>
<p>For deep understanding of query optimization look at <a href="https://github.com/orientechnologies/orientdb/blob/master/tests/src/test/java/com/orientechnologies/orient/test/database/auto/SQLSelectIndexReuseTest.java">the unit test</a>.</p>
<h3 id="use-parameters-instead-of-hard-wired-values"><a class="header" href="#use-parameters-instead-of-hard-wired-values">Use parameters instead of hard-wired values</a></h3>
<p>Query parsing is not an extremely expensive operation, but zero cost is better than low cost, right?</p>
<p>When you execute an SQL query, OrientDB parses the query text and produces an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>. This structure is cached at storage level, so if you execute the query again, OrientDB will avoid to parse it again and will just pick the AST from the cache.</p>
<p>In most cases, your application will execute a very limited number of queries, but with different condition values, eg.</p>
<pre><code class="language-sql">SELECT FROM Person WHERE name = 'Joe';
SELECT FROM Person WHERE name = 'Jenny';
SELECT FROM Person WHERE name = 'Frank';
SELECT FROM Person WHERE name = 'Anne';
</code></pre>
<p>With these queries, OrientDB has to perform parsing operations each time.</p>
<p>Re-writing the query as follows:</p>
<pre><code class="language-sql">SELECT FROM Person WHERE name = ?;
</code></pre>
<p>or</p>
<pre><code class="language-sql">SELECT FROM Person WHERE name = :theName;
</code></pre>
<p>and passing the name as a parameter (see the docs for your language driver, eg <a href="../java/Java-Query-API.html">the Java Multi-Model API</a>) allows OrientDB to parse the query only once and then cache it. The second time you execute the same query, even with different parameters, there will be no parsing at all.</p>
<h3 id="parallel-queries"><a class="header" href="#parallel-queries">Parallel queries</a></h3>
<p>Starting from v2.2, the OrientDB SQL executor will decide if execute or not a query in parallel. To tune parallel query execution these are the new settings:</p>
<ul>
<li><code>query.parallelAuto</code> enable automatic parallel query, if requirements are met. By default is true if your system has more than 2 CPUs/Cores.</li>
<li><code>query.parallelMinimumRecords</code> is the minimum number of records to activate parallel query automatically. Default is 300,000.</li>
<li><code>query.parallelResultQueueSize</code> is the size of the queue that holds results on parallel execution. The queue is blocking, so in case the queue is full, the query threads will be in a wait state. Default is 20,000 results.</li>
</ul>
<h2 id="massive-insertion"><a class="header" href="#massive-insertion">Massive Insertion</a></h2>
<h3 id="use-the-massive-insert-intent"><a class="header" href="#use-the-massive-insert-intent">Use the Massive Insert intent</a></h3>
<p>Intents suggest to OrientDB what you're going to do. In this case you're telling to OrientDB that you're executing a massive insertion. OrientDB auto-reconfigure itself to obtain the best performance. When done you can remove the intent just setting it to null.</p>
<p>Example:</p>
<pre><code class="language-java">db.declareIntent( new OIntentMassiveInsert() );

// YOUR MASSIVE INSERTION

db.declareIntent( null );
</code></pre>
<h3 id="disable-journal"><a class="header" href="#disable-journal">Disable Journal</a></h3>
<p>In case of massive insertion, specially when this operation is made just once, you could disable the journal (WAL) to improve insertion speed:</p>
<pre><code>-Dstorage.useWAL=false
</code></pre>
<p>By default <a href="../internals/Write-Ahead-Log.html">WAL (Write Ahead Log)</a> is enabled.</p>
<h3 id="disable-sync-on-flush-of-pages"><a class="header" href="#disable-sync-on-flush-of-pages">Disable sync on flush of pages</a></h3>
<p>This setting avoids to execute a sync at OS level when a page is flushed. Disabling this setting will improve throughput on writes:</p>
<pre><code>-Dstorage.wal.syncOnPageFlush=false
</code></pre>
<h2 id="massive-updates"><a class="header" href="#massive-updates">Massive Updates</a></h2>
<p>Updates generates "holes" at Storage level because rarely the new record fits perfectly the size of the previous one. Holes are free spaces between data. Holes are recycled but an excessive number of small holes it's the same as having a highly defragmented File System: space is wasted (because small holes can't be easily recycled) and performance degrades when the database growth.</p>
<h3 id="oversize"><a class="header" href="#oversize">Oversize</a></h3>
<p>If you know you will update certain type of records, create a class for them and set the Oversize (default is 0) to 2 or more.</p>
<p>By default the OGraphVertex class has an oversize value setted at 2. If you define your own classes set this value at least at 2.</p>
<p>OClass myClass = getMetadata().getSchema().createClass("Car");
myClass.setOverSize(2);</p>
<h2 id="wise-use-of-transactions"><a class="header" href="#wise-use-of-transactions">Wise use of transactions</a></h2>
<p>To obtain real linear performance with OrientDB you should avoid to use <a href="../internals/Transactions.html">Transactions</a> as far as you can. In facts OrientDB keeps in memory all the changes until you flush it with a commit. So the bottleneck is your Heap space and the management of local transaction cache (implemented as a Map).</p>
<p><a href="../internals/Transactions.html">Transactions</a> slow down massive inserts unless you're using a "remote" connection. In that case it speeds up all the insertion because the client/server communication happens only at commit time.</p>
<h3 id="disable-transaction-log"><a class="header" href="#disable-transaction-log">Disable Transaction Log</a></h3>
<p>If you need to group operations to speed up remote execution in a logical transaction but renouncing to the Transaction Log, just disable it by setting the property <strong>tx.useLog</strong> to false.</p>
<p>Via JVM configuration:</p>
<pre><code>java ... -Dtx.useLog=false ...
</code></pre>
<p>or via API:</p>
<pre><code class="language-java">OGlobalConfiguration.TX_USE_LOG.setValue(false);
</code></pre>
<p><em>NOTE: Please note that in case of crash of the JVM the pending transaction OrientDB could not be able to rollback it.</em></p>
<h3 id="use-the-schema"><a class="header" href="#use-the-schema">Use the schema</a></h3>
<p>Starting from OrientDB 2.0, if fields are declared in the schema, field names are not stored in document/vertex/edge themselves. This improves performance and saves a lot of space on disk.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>To tune OrientDB look at the <a href="../admin/Configuration.html">Configuration</a> settings.</p>
<h2 id="platforms"><a class="header" href="#platforms">Platforms</a></h2>
<ul>
<li><a href="http://carloprad.blogspot.it/2014/03/orientdb-on-zfs-performance-analysis.html">Performance analysis on ZFS</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../troubleshooting/Direct-Memory-Tracing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tuning/Performance-Tuning-Graph.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../troubleshooting/Direct-Memory-Tracing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tuning/Performance-Tuning-Graph.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
